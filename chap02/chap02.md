# Chap02 - Hello World in Assembly

## 実験ログ
### 出力を逆順(FFEEAADDCCBBAA)で出したい
```diff
- lea rsi, [codes + rax]
+ lea rsi, [codes + 15 - rax]
```
この変更では
```bash
print_rax.asm:20: error: invalid effective address
```
のエラーが出た。  
アセンブラでは`[base + index*scale + offset]`という形しか理解できないので、構文エラーとなっている。
そのため、引き算はあらかじめ行う。  

```
mov rdx, 16
sub rdx, rax
lea rsi, [codes + rdx]
mov rdx, 1
```
これで逆順の主力
```bash
FFEEDDCCBBAA9988
```
が得られた。  
rdxを使用しているので、最後にシステムコールで使用するために1を入れることを忘れない
## 気づき
- （とりあえず bullet で雑にメモ）

## 疑問
### RAXレジスタとは？
RAX は汎用レジスタの1つで、主にシステムコール番号の格納に使われる。
一方、最初の引数（第1引数）は RDI に渡される。  
セクションを分ける理由は？  
メモリ保護と効率化のため。  
- `.text`：実行可能なコード領域（基本的に読み取り専用）
- `.data`：初期化済みデータ（読み書き可能）
- `.bss`：未初期化データ（自動的にゼロで初期化される）

### sar 命令とは？
`sar` は算術シフト（右シフト）命令。
`sar a, b` は「aをbビット右にシフトして結果をaに書き戻す」ことを意味する。符号付き数に対して、符号ビットを保ったまま右シフトする。

### clとは？
`cl`とはrcx(カウントレジスタ)の「下位8ビット部分」  
`sar rax, cl` とすると可変シフトとなり、rcxの下位8ビットの値だけシフトする

### プッシュした値はどこに保存される？
スタックメモリ`rsp`に保持される。

### leaとは？
`lea`はアドレスを計算してその結果をレジスタに入れる命令  
メモリの中身を読まずに、アドレスそのものを計算する  

## Practice problems
### 問題11
mov rdi, 0 と同じ動作をするのが xor rdi, rdi。
ただし後者は短く、かつCPUフラグも自動的にクリアされる。

### 問題12
戻り値（return code）は 0。

### 問題13
最初の引数（第1引数）は rdi に渡される。
この場合の値は 0。

### 問題14
codesテーブルの先頭アドレスからraxを足したアドレスを確認するとASCIIコードと同様になっている

### 問題15
`sar`算術シフト(符号ビットをコピー)の右シフト  
`shr`論理シフト(0埋め)の右シフト

### 問題16
8進数や16進数様々な形で数値を表現できる


## 次やること
- （TODOリスト感覚）
